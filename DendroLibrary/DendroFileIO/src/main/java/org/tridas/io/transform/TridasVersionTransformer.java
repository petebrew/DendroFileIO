package org.tridas.io.transform;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.tridas.io.I18n;
import org.tridas.io.TridasIO;
import org.tridas.io.util.FileHelper;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;

/**
 * Converts TRiDaS files between various versions.  The transform is performed between one version and its successor (or predecessor for downgrades).  If the user
 * requests to upgrade across multiple versions, then a step-wise transform is performed for each step.  The transforms are performed by running the XML file with 
 * an XSL file. 
 * 
 * @author pbrewer
 *
 */
public class TridasVersionTransformer {

	private final static Logger log = LoggerFactory.getLogger(TridasVersionTransformer.class);
	

	public static void main(String[] args)
	{
		try {
			TridasVersionTransformer.transformTridas(
					new File("/home/pwb48/dev/java8/DendroFileIO/TestData/TRiDaS/Extensive.xml"), 
					TridasVersion.V_1_2_1);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

		
	public static File transformTridas(File inputFile, TridasVersion outputVersion) throws Exception {
		
		// Read the input file and determine it's current version
		TridasVersion inputVersion = getTridasVersionFromXML(inputFile);
		if(inputVersion==null) 
		{
			throw new Exception("Unable to determine version of existing TRiDaS file so version transformation failed");
		}
		
		// Create a list of XSL file streams one for each step in the upgrade/downgrade process.
		ArrayList<InputStream> xsllist = new ArrayList<InputStream>();
		if(inputVersion.equals(outputVersion))
		{
			log.info("The input file is already v"+inputVersion.versionString+" so file will not be transformed");
			return inputFile;
		}
		if(inputVersion.equals(TridasVersion.V_1_2_2) &&
				outputVersion.equals(TridasVersion.V_1_2_3))
		{		
			log.debug("User has requested to upgrade their file from v1.2.2 to v.1.2.3");
			InputStream xslstream = TridasIO.class.getResourceAsStream("/xslt/Upgrade1.2.2-to-1.2.3.xsl");
			xsllist.add(xslstream);
		}
		else if (inputVersion.equals(TridasVersion.V_1_2_3) &&
				outputVersion.equals(TridasVersion.V_1_2_2))
		{
			log.debug("User has requested to upgrade their file from v1.2.3 to v.1.2.2");
			InputStream xslstream = TridasIO.class.getResourceAsStream("/xslt/Downgrade1.2.3-to-1.2.2.xsl");
			xsllist.add(xslstream);
		}
		//TODO Add support for other steps
		else
		{			
			throw new Exception("Transforming from v"+inputVersion.versionString+" to v"+outputVersion.versionString+" is currently not supported");
		}

		// Run each XSL transform in turn
		File currentFile = inputFile;
		for(InputStream currentXSL : xsllist)
		{
			currentFile = xslTransform(currentFile, currentXSL);
			if(currentFile==null) throw new Exception("Failed to transform TRiDaS file");
		}
		
		// Return the converted file
		return currentFile;
	}
	
	/**
	 * Applies an XSL transform to the specified input file using the XSL file specified as an InputStream
	 * 
	 * @param inputFile
	 * @param xslstream
	 * @return
	 */
	public static File xslTransform(File inputFile, InputStream xslstream) {

		if(inputFile==null || xslstream == null )
		{
			log.error("All parameters are required.  Unable to perform transform.");
			return null;
		}


		File outputFile = new File("/tmp/output.xml");
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

			
		//factory.setNamespaceAware(true);
		//factory.setValidating(true);
		try {


			DocumentBuilder builder = factory.newDocumentBuilder();
			Document document = builder.parse(inputFile);

			// Use a Transformer for output
			TransformerFactory tFactory = TransformerFactory.newInstance();
			StreamSource stylesource = new StreamSource(xslstream);
			Transformer transformer = tFactory.newTransformer(stylesource);

			DOMSource source = new DOMSource(document);
			StreamResult result = new StreamResult(outputFile);
			transformer.transform(source, result);
			
			
		} catch (TransformerConfigurationException tce) {
			// Error generated by the parser
			log.error("\n** Transformer Factory error");
			log.error("   " + tce.getMessage());

			// Use the contained exception, if any
			Throwable x = tce;

			if (tce.getException() != null) {
				x = tce.getException();
			}

			x.printStackTrace();
			return null;
		} catch (TransformerException te) {
			// Error generated by the parser
			log.error("\n** Transformation error");
			log.error("   " + te.getMessage());

			// Use the contained exception, if any
			Throwable x = te;

			if (te.getException() != null) {
				x = te.getException();
			}

			x.printStackTrace();
			return null;
		} catch (SAXException sxe) {
			// Error generated by this application
			// (or a parser-initialization error)
			Exception x = sxe;

			if (sxe.getException() != null) {
				x = sxe.getException();
			}

			x.printStackTrace();
			return null;
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		} catch (IOException ioe) {
			// I/O error
			ioe.printStackTrace();
			return null;
		}

		log.debug("Transformation complete!");
		return outputFile;
	} // main
	

	/**
	 * Get the TRiDaS version number of the specified TRiDaS input file 
	 * 
	 * @param inputFile
	 * @return
	 */
	public static TridasVersion getTridasVersionFromXML(File inputFile)
	{
		
		FileHelper fileHelper = new FileHelper(inputFile.getAbsolutePath());
		log.debug("loading file: " + inputFile.getAbsolutePath());
		String[] strings;
		try{
			if (TridasIO.getReadingCharset() != null) {
				strings = fileHelper.loadStrings(inputFile.getAbsolutePath(), TridasIO.getReadingCharset());
			}
			else {
				if (TridasIO.isCharsetDetection()) {
					strings = fileHelper.loadStringsFromDetectedCharset(inputFile.getAbsolutePath());
				}
				else {
					strings = fileHelper.loadStrings(inputFile.getAbsolutePath());
				}
			}
			if (strings == null) {
				throw new IOException(I18n.getText("fileio.loadfailed"));
			}
		
		
			for(String line : strings)
			{
				if(line.contains("http://www.tridas.org/1.2.3")) return TridasVersion.V_1_2_3;
				if(line.contains("http://www.tridas.org/1.2.2")) return TridasVersion.V_1_2_2;
				if(line.contains("http://www.tridas.org/1.2.1")) return TridasVersion.V_1_2_1;
				if(line.contains("http://www.tridas.org/1.2")) return TridasVersion.V_1_2;
				if(line.contains("http://www.tridas.org/1.1")) return TridasVersion.V_1_1;
				if(line.contains("http://www.tridas.org/1.0")) return TridasVersion.V_1_0;
			}
		}
		catch (UnsupportedEncodingException e){
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		return null;
	}
	
	
	enum TridasVersion{
		V_1_0(1, "1.0"),
		V_1_1(2, "1.1"),
		V_1_2(3, "1.2"),
		V_1_2_1(4, "1.2.1"),
		V_1_2_2(5, "1.2.2"),
		V_1_2_3(6, "1.2.3b");
		
		private int sequence;
		private String versionString;
		
		TridasVersion(int sequence, String versionString)
		{
			this.sequence = sequence;
			this.versionString = versionString;
		}
		
		public int getSequence()
		{
			return sequence;
		}
		
		public String getVersionString()
		{
			return versionString;
		}	
	}
}
